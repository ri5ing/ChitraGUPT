/**
 * @fileoverview Firestore Security Rules for ChitraGupt application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for private user data,
 * while allowing public read access to certain collections like auditor profiles.
 *
 * Data Structure:
 * The data is organized hierarchically under /users/{userId}, ensuring that user-specific
 * data is isolated and accessible only to the owner. Auditor profiles are stored
 * in a top-level collection for public discoverability.
 *
 * Key Security Decisions:
 * - Users can only access their own profile and data nested under their profile.
 * - Auditor profiles are publicly readable but only writable by the auditor themselves.
 * - Listing of user profiles is disallowed to prevent enumeration attacks.
 * - All write operations are validated to ensure data consistency and ownership.
 * - All destructive operations check that resource exists.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profile information, ensuring only the owner can read and write.
     * @path /users/{userId}
     * @allow (create, update, delete) User with UID 'user123' can create/update/delete their own profile at /users/user123.
     * @deny (create, update, delete) User with UID 'user456' cannot create/update/delete the profile at /users/user123.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Disabling listing for security.

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures auditor profile information, allowing public read but restricting writes to the auditor.
     * @path /auditors/{auditorId}
     * @allow (get, list) Any authenticated user can read the auditor profiles.
     * @allow (create, update, delete) Auditor with UID 'auditor123' can create/update/delete their own profile at /auditors/auditor123.
     * @deny (create, update, delete) User with UID 'user456' cannot create/update/delete the profile at /auditors/auditor123.
     * @principle Allows public read access while enforcing ownership for writes.
     */
    match /auditors/{auditorId} {
      function isOwner(auditorId) {
        return request.auth != null && request.auth.uid == auditorId;
      }

      function isExistingOwner(auditorId) {
        return isOwner(auditorId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isOwner(auditorId) && request.resource.data.id == auditorId;
      allow update: if isExistingOwner(auditorId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(auditorId);
    }

    /**
     * @description Secures contracts uploaded by users, ensuring only the owner can access them.
     * @path /users/{userId}/contracts/{contractId}
     * @allow (create, update, delete) User with UID 'user123' can create/update/delete their own contract at /users/user123/contracts/contract456.
     * @deny (create, update, delete) User with UID 'user456' cannot create/update/delete the contract at /users/user123/contracts/contract456.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/contracts/{contractId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures AI analysis reports for contracts, ensuring only the owner can access them.
     * @path /users/{userId}/contracts/{contractId}/analysisReports/{analysisReportId}
     * @allow (create, update, delete) User with UID 'user123' can create/update/delete the analysis report for their own contract.
     * @deny (create, update, delete) User with UID 'user456' cannot create/update/delete the analysis report for another user's contract.
     * @principle Enforces document ownership based on the parent contract.
     */
    match /users/{userId}/contracts/{contractId}/analysisReports/{analysisReportId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures auditor feedback for contracts, ensuring only authorized auditors can add feedback.
     * @path /users/{userId}/contracts/{contractId}/auditorFeedback/{auditorFeedbackId}
     * @allow (create, update, delete) Only authorized auditors can create/update/delete feedback for a contract.
     * @deny (create, update, delete) Regular users cannot create/update/delete auditor feedback.
     * @principle Restricts write access to authorized auditors.
     */
    match /users/{userId}/contracts/{contractId}/auditorFeedback/{auditorFeedbackId} {
       function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures annotations made by auditors on contracts, linking them to a contract and auditor.
     * @path /users/{userId}/contracts/{contractId}/annotations/{annotationId}
     * @allow (create, update, delete) Only authorized auditors can create/update/delete annotations on a contract.
     * @deny (create, update, delete) Regular users cannot create/update/delete annotations.
     * @principle Restricts write access to authorized auditors, enforcing relational integrity.
     */
    match /users/{userId}/contracts/{contractId}/annotations/{annotationId} {
       function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
     * @description Secures chat messages for contract reviews, controlling access between client and auditor.
     * @path /users/{userId}/contracts/{contractId}/chats/{messageId}
     * @allow (create, update, delete) Only the involved client or auditor can create/update/delete chat messages.
     * @deny (create, update, delete) Unauthorized users cannot create/update/delete chat messages.
     * @principle Ensures secure communication between parties by restricting access.
     */
    match /users/{userId}/contracts/{contractId}/chats/{messageId} {
       function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}