/**
 * @fileoverview Firestore Security Rules for ChitraGupt application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for private user data,
 * while allowing public read access to certain collections like auditor profiles
 * and public reports.  Data validation is minimized in this prototyping phase
 * to allow for rapid schema iteration, focusing instead on secure authorization.
 *
 * Data Structure:
 * - `/users/{userId}`:  User profiles, accessible only by the user themselves.
 * - `/auditors/{auditorId}`: Public auditor profiles, readable by all authenticated users,
 *   writable only by the auditor or an admin.
 * - `/users/{userId}/contracts/{contractId}`: Contracts owned by a specific user.
 * - `/contracts/{contractId}`: A top-level collection of contracts for auditor queries.
 * - `/publicReports/{reportId}`: Publicly readable contract analysis reports.
 * - `/reviewRequests/{requestId}`: Contract review requests, accessible to the client and assigned auditor.
 *
 * Key Security Decisions:
 * - User listing is disallowed for security reasons.
 * - Public reports are readable by anyone but writable only by server-side logic.
 * - Strict ownership is enforced for user profiles and contracts within the user's path.
 *
 * Denormalization for Authorization:
 *  - The rules rely on path-based ownership (`/users/{userId}`) to avoid `get()` calls
 *    and efficiently enforce access control.
 *  - A top-level `/contracts` collection is added for auditors to query their history.
 *    This is a design choice to enable cross-user queries needed by auditors.
 */

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource.data.id == userId;
    }

    function isAuditor() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'auditor';
    }

    function isAssignedAuditor(auditorId) {
        return request.auth.uid == auditorId;
    }
    
    function isRequestingClient(clientId) {
        return request.auth.uid == clientId;
    }

    /**
     * @description Controls access to user profile information.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get, update, delete: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow list: if false;
    }

    /**
     * @description Controls access to public auditor profiles.
     * @path /auditors/{auditorId}
     */
    match /auditors/{auditorId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isOwner(auditorId);
    }

    /**
     * @description Controls access to contracts uploaded by users.
     * @path /users/{userId}/contracts/{contractId}
     */
    match /users/{userId}/contracts/{contractId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      // Allow auditor to update status/feedback, but client can update title etc.
      allow update: if isOwner(userId) || isAssignedAuditor(resource.data.auditorId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to the top-level contracts collection for auditor queries.
     * @path /contracts/{contractId}
     */
    match /contracts/{contractId} {
        // Only assigned auditors can read from this collection for their history.
        allow get, list: if isAuditor() && isAssignedAuditor(resource.data.auditorId);
        // Writes to this collection should be handled by backend logic/transactions, not clients.
        allow write: if false;
    }

    /**
     * @description Controls access to public contract reports.
     * @path /publicReports/{reportId}
     */
    match /publicReports/{reportId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Controls access to contract review requests.
     * @path /reviewRequests/{requestId}
     */
    match /reviewRequests/{requestId} {
        allow get: if isSignedIn() && (isRequestingClient(resource.data.clientId) || isAssignedAuditor(resource.data.auditorId));
        allow create: if isSignedIn() && isRequestingClient(request.resource.data.clientId);
        allow update, delete: if isSignedIn() && isAssignedAuditor(resource.data.auditorId);
        allow list: if false;
    }

    /**
     * @description Controls access to chat messages for a specific contract review.
     * @path /users/{userId}/contracts/{contractId}/chats/{messageId}
     */
    match /users/{userId}/contracts/{contractId}/chats/{messageId} {
      // The client who owns the contract, or the assigned auditor can read/write chat messages.
      function isParticipant() {
        let contract = get(/databases/$(database)/documents/users/$(userId)/contracts/$(contractId));
        return isOwner(userId) || isAssignedAuditor(contract.data.auditorId);
      }

      allow get, list, create: if isParticipant();
      allow update, delete: if false;
    }

    // Read-only subcollections for clients. Writes are handled by server/transactions.
    match /users/{userId}/contracts/{contractId}/{subcollection}/{docId} {
       allow get, list: if isOwner(userId);
       allow write: if false;
    }
  }
}
