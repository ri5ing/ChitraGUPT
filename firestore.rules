/**
 * @fileoverview Firestore Security Rules for ChitraGupt application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for private user data,
 * while allowing public read access to auditor profiles.  It also governs
 * access to contracts, analysis reports, auditor feedback, annotations, and chats,
 * ensuring only authorized users (owners or assigned auditors) can read and modify them.
 *
 * Data Structure:
 * - /users/{userId}: User profile information (private, owner-only access).
 * - /auditors/{auditorId}: Auditor profiles (public read, auditor- or admin-write).
 * - /users/{userId}/contracts/{contractId}: Contracts owned by a user.
 * - /users/{userId}/contracts/{contractId}/analysisReports/{analysisReportId}: AI analysis reports for contracts.
 * - /users/{userId}/contracts/{contractId}/auditorFeedback/{auditorFeedbackId}: Auditor feedback on contracts.
 * - /users/{userId}/contracts/{contractId}/annotations/{annotationId}: Annotations on contracts by auditors.
 * - /users/{userId}/contracts/{contractId}/chats/{messageId}: Chat messages between users and auditors.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Public read access is granted to auditor profiles, but writes are restricted.
 * - All other collections enforce strict owner-only or authorized-auditor access.
 *
 * Denormalization for Authorization:
 * To simplify rules and improve performance, the rules assume that authorization-related data
 * (e.g., user roles, contract ownership) is denormalized directly into the documents. For example,
 * contracts have a 'userId' field.
 *
 * Structural Segregation:
 * The application uses separate collections to manage public (auditor profiles) and private data (user profiles, contracts).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profile information.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile with matching ID.
     * @allow (get, update, delete) User with ID 'user123' can read/update/delete their own profile.
     * @deny (create) User with ID 'user456' cannot create a profile for user 'user123'.
     * @deny (list) Listing all users is not permitted.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Secure public-facing auditor profiles.
     * @path /auditors/{auditorId}
     * @allow (get, list) Any authenticated user can read auditor profiles.
     * @allow (create, update, delete) Only the auditor themselves can create/update/delete their profile.
     * @deny (create, update, delete) Another user cannot create/update/delete an auditor's profile.
     * @principle Public read access with owner-only writes.
     */
    match /auditors/{auditorId} {
      function isOwner(auditorId) {
        return request.auth.uid == auditorId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isOwner(auditorId) && request.resource.data.id == auditorId;
      allow update: if isSignedIn() && isOwner(auditorId) && request.resource.data.id == auditorId;
      allow delete: if isSignedIn() && isOwner(auditorId);
    }

    /**
     * @description Secure contracts uploaded by users.
     * @path /users/{userId}/contracts/{contractId}
     * @allow (create) User with ID 'user123' can create a contract under their user ID.
     * @allow (get, update, delete) User with ID 'user123' can read/update/delete their own contracts.
     * @deny (create) User with ID 'user456' cannot create a contract for user 'user123'.
     * @deny (list) Other users cannot list user123 contracts.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/contracts/{contractId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Secure AI analysis reports for each contract.
     * @path /users/{userId}/contracts/{contractId}/analysisReports/{analysisReportId}
     * @allow (get, create, update, delete) Only the owner of the contract can manage analysis reports.
     * @deny (list) Other users cannot list the analysis report.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/contracts/{contractId}/analysisReports/{analysisReportId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Secure auditor feedback for each contract.
     * @path /users/{userId}/contracts/{contractId}/auditorFeedback/{auditorFeedbackId}
     * @allow (get, create, update, delete) Only the owner of the contract can manage auditor feedback.
     * @deny (list) Other users cannot list the auditor feedback.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/contracts/{contractId}/auditorFeedback/{auditorFeedbackId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isOwner(userId) && isSignedIn();
    }

    /**
     * @description Secure annotations made by auditors on specific contracts.
     * @path /users/{userId}/contracts/{contractId}/annotations/{annotationId}
     * @allow (get, create, update, delete) Only the owner of the contract can manage annotations.
     * @deny (list) Other users cannot list the annotation.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/contracts/{contractId}/annotations/{annotationId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isOwner(userId) && isSignedIn();
    }

        /**
     * @description Secure chat messages for a specific contract review between a client and an auditor.
     * @path /users/{userId}/contracts/{contractId}/chats/{messageId}
     * @allow (get, create, update, delete) Only the owner of the contract can manage chat messages.
     * @deny (list) Other users cannot list the chat messages.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/contracts/{contractId}/chats/{messageId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isOwner(userId) && isSignedIn();
    }
  }
}